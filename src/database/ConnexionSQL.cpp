#include "ConnexionSQL.h"
#include <QSqlQuery>
#include <QSqlError>
#include <QDebug>
#include <QFile>
#include <QTextStream>
#include <QVariantList>

ConnexionSQL& ConnexionSQL::instance()
{
    static ConnexionSQL inst;
    return inst;
}

ConnexionSQL::ConnexionSQL()
{
}

ConnexionSQL::~ConnexionSQL()
{
    disconnect();
}

bool ConnexionSQL::connectMySQL(const QString &host, const QString &user, const QString &password, const QString &database, int port)
{
    if (m_connected && m_db.isOpen()) return true;

    // Use a connection name to avoid interfering with default connection
    const QString connName = "qt_mysql_conn";

    if (QSqlDatabase::contains(connName)) {
        m_db = QSqlDatabase::database(connName);
    } else {
        m_db = QSqlDatabase::addDatabase("QMYSQL", connName);
    }

    m_db.setHostName(host);
    m_db.setUserName(user);
    m_db.setPassword(password);
    m_db.setDatabaseName(database);
    m_db.setPort(port);

    if (!m_db.open()) {
        qWarning() << "Connexion MySQL échouée:" << m_db.lastError().text();
        m_connected = false;
        return false;
    }

    m_connected = true;
    return true;
}

QSqlDatabase ConnexionSQL::database() const
{
    return m_db;
}

bool ConnexionSQL::isConnected() const
{
    return m_connected && m_db.isOpen();
}

void ConnexionSQL::disconnect()
{
    if (!m_db.isValid()) return;
    QString name = m_db.connectionName();
    if (m_db.isOpen()) m_db.close();
    QSqlDatabase::removeDatabase(name);
    m_connected = false;
}

// Helper to escape string for SQL literal (basic)
static QString escapeValue(const QVariant &v)
{
    if (v.isNull()) return "NULL";
    if (v.type() == QVariant::String || v.type() == QVariant::ByteArray || v.type() == QVariant::Char) {
        QString s = v.toString();
        s.replace("\\", "\\\\");
        s.replace("'", "\\'");
        return QString("'%1'").arg(s);
    }
    // For date/time types cast to string
    if (v.type() == QVariant::Date || v.type() == QVariant::DateTime || v.type() == QVariant::Time) {
        return QString("'%1'").arg(v.toString());
    }
    // Numeric or other
    return v.toString();
}

bool ConnexionSQL::exportSchema(const QString &filePath, QString *errorMsg)
{
    if (!isConnected()) {
        if (errorMsg) *errorMsg = "Not connected to MySQL.";
        return false;
    }

    QFile out(filePath);
    if (!out.open(QIODevice::WriteOnly | QIODevice::Text)) {
        if (errorMsg) *errorMsg = QString("Unable to open file %1 for writing").arg(filePath);
        return false;
    }
    QTextStream ts(&out);
    ts.setCodec("UTF-8");
    QSqlQuery q(m_db);

    // Get list of tables
    if (!q.exec("SHOW TABLES")) {
        if (errorMsg) *errorMsg = q.lastError().text();
        out.close();
        return false;
    }

    QStringList tables;
    while (q.next()) {
        tables << q.value(0).toString();
    }

    ts << "-- SQL dump generated by ConnexionSQL::exportSchema\n";
    ts << "-- Tables: " << tables.join(", ") << "\n\n";
    ts << "SET FOREIGN_KEY_CHECKS = 0;\n\n";

    // For each table, write CREATE TABLE and INSERTs
    for (const QString &t : tables) {
        QSqlQuery q2(m_db);
        QString stmt = QString("SHOW CREATE TABLE `%1`").arg(t);
        if (!q2.exec(stmt)) {
            qWarning() << "SHOW CREATE TABLE failed for" << t << ":" << q2.lastError().text();
            if (errorMsg) *errorMsg = q2.lastError().text();
            out.close();
            return false;
        }
        if (q2.next()) {
            QString createStmt = q2.value(1).toString();
            ts << "-- ----------------------------\n";
            ts << "-- Table structure for `" << t << "`\n";
            ts << "-- ----------------------------\n";
            ts << createStmt << ";\n\n";
        }

        // Dump data
        QSqlQuery q3(m_db);
        QString sel = QString("SELECT * FROM `%1`").arg(t);
        if (!q3.exec(sel)) {
            qWarning() << "SELECT * failed for" << t << ":" << q3.lastError().text();
            if (errorMsg) *errorMsg = q3.lastError().text();
            out.close();
            return false;
        }

        QList<QString> insertLines;
        // Build INSERTs in batches to avoid giant statements; here one row per INSERT for simplicity
        while (q3.next()) {
            int colCount = q3.record().count();
            QStringList values;
            for (int i = 0; i < colCount; ++i) {
                values << escapeValue(q3.value(i));
            }
            QString ins = QString("INSERT INTO `%1` VALUES (%2);").arg(t).arg(values.join(", "));
            insertLines << ins;
        }

        if (!insertLines.isEmpty()) {
            ts << "-- ----------------------------\n";
            ts << "-- Data for table `" << t << "`\n";
            ts << "-- ----------------------------\n";
            for (const QString &il : insertLines) ts << il << "\n";
            ts << "\n";
        }
    }

    ts << "SET FOREIGN_KEY_CHECKS = 1;\n";
    out.close();
    return true;
}